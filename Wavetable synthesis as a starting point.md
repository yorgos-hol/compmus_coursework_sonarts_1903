# Δημιουργία synths χρησιμοποιώντας τη wavetable synthesis ως αφετηρία
## Σύνοψη

Η παρούσα εργασία στοχεύει στην αναζήτηση μεθόδων επεξεργασίας κυματομορφών που είναι αποθηκευμένες σε δείγματα. Η επεξεργασία τους αυτή γίνεται στο πλαίσιο δημιουργίας διάφορων synths, με γνώμονα τον πειραματισμό πάνω στον ηχητικό σχεδιασμό. Ο σχεδιασμός ήχων μέσω plug-ins  είναι μία διαδικασία με την οποία είμαι εξοικειωμένος, ωστόσο στο περιβάλλον του κώδικα supercollider απαιτεί κατανόηση μαθηματικών λειτουργιών και λογικής ως η ιεράρχηση και επιλογή ενεργειών και προγραμματισμού συλλογισμών. Επομένως, ο κώδικας τον οποίο συνοδεύει το παρόν κείμενο αποτελεί μία πρώτη απόπειρα εξερεύνησης της λογικής ως μέθοδος παραγωγής ιδιαίτερων ήχων. 

Ο κώδικας περιλαμβάνει μία μέθοδο συμπλήρωσης κυματομορφής η οποία διαβάζεται πλέον ως wavetable. Έπειτα όμως ως βάση χρησιμοποιούνται κυματομορφές αποθηκευμένες σε αρχεία και buffer. Αυτές δημιουργήθηκαν με το πρόγραμμα Audacity, ενώ προβλέπεται και μέθοδος χρήσης οποιουδήποτε ηχητικού δείγματος ως κυματομορφή, καθώς η μέθοδος Buffer.read είναι προγραμματισμένη να διαβάζει 512 frames, καθιστώντας κάθε sample έτοιμο προς μετατροπή σε wavetable. Αυτό συμβαίνει γιατί στη wavetable synthesis είναι απαραίτητη η χρήση sample που έχουν αριθμό frames ίσο με αριθμό δύναμης του 2, εξαιτίας του modulo που χρησιμοποιεί η γεννήτρια (Bristow-Johnson, R. 1996. Wavetable synthesis 101, a fundamental perspective. In *Audio Engineering Society Convention 101. Audio Engineering Society*. ResearchGate http://www.researchgate.net/ (accessed April 3, 2019)).

Σ'αυτό το σημείο πρέπει να σημειωθεί ότι κάποιες μέθοδοι συμπλήρωσης wavetable δεν εφαρμόστηκαν στην παρούσα εργασία, καθώς προτιμήθηκε η διαισθητικότερη παραγωγή κυματομορφών, αλλά κυρίως η χρήση συγκεκριμένων sample. Μία μη περιλαμβανόμενη μέθοδος είναι ο προγραμματισμός κυματομορφής μέσω envelope generator στο supercollider. Παράδειγμα: 

       (
        ~env = Env.new(
	  {rrand(-1.0,1.0)}!11,
	  {exprand(0.001,3)}!10,
	  {rrand(-3.0,6.0)}!10
       );
       )
       ~env.plot; 


Σημ.: για τις ψευδοτυχαίες τιμές διαρκειών επιλέχθηκε το exprand γιατί καταλήγει σε αλλαγές που συμβαίνουν σε όχι υπερβολικά γρήγορο ρυθμό - κάτι που δε θα γινόταν άλλωστε εμφανώς φανερό ακουστικά, ή τουλάχιστον θα ήταν αναποτελεσματικό, άλλωστε, πέραν μίας επιπλέον εισαγωγής θορύβου)
Κάτι που αποφέυχθηκε είναι το γράψιμο συνάρτησης μεταφοράς βάσει απόλυτα συγκεκριμένων, ήδη γνωστών και υπολογισμένων μαθηματικών υπολογισμών π.χ. παραγωγής ημιτονοειδούς κύματος (βλ. τριγωνομετρία κτλ.). Παράδειγμα:

    (
    ~sig = Signal.newClear(513);
    ~sig.waveFill({
	arg x, y, i;
	sin(x)
    }, 0, 4pi)
    )

    ~sig.plot;
    
Σημ.: εδώ παρατηρούμε ότι γίνεται συμπλήρωση 513 frames. Το supercollider σε ανάλογες περιπτώσεις χρειάζεται pow(2)+1 (αριθμός-δύναμη του 2 + 1) frames.

## Κάποιες πιο στοχευμένες επισημάνσεις για τον κώδικα που συντάχθηκε

(ΓΡΑΜΜΕΣ 1-15) Τελικά λοιπόν, χρησιμοποιήθηκε μία (ψευδο)τυχαιοποιημένη μέθοδος συμπλήρωσης τιμών για τις κυματομορφές που δε δημιουργήθηκαν μέσω audacity, όπως είναι η πρώτη. Ο κώδικας φυσικά προσφέρει τη δυνατότητα επιλογής του directory στο οποίο θα αποθηκευτούν οι κυματομορφές για την περαιτέρω χρήση τους αργότερα.

(25-72), (76-84) Οι δύο αυτές περίοδοι και ειδικότερα η πρώτη (25-72) αποτελούν βασικά σημεία του κώδικα, καθώς περιέχουν ορισμούς στους οποίους πρέπει να γίνει evaluation ώστε να λειτουργήσουν τα υπόλοιπα μέρη του.

(25-41) Για την πιο βολική συστηματοποίηση της πλοήγησης και του τρόπου εισαγωγής εξωτερικών αρχείων επιλέχθηκε το class dictionary, μία υποκατηγορία collection. Ο λόγος είναι ότι το dictionary, σε αντίθεση με το array, μπορεί να προγραμματιστεί έτσι ώστε να βλέπει όλους τους υποφακέλους ως "λήμματα"-values, των οποίων τα ονόματα καθίστανται ως symbols, κάνοντας τον εντοπισμό και την επιλογή αρχείων και φακέλων πολύ εύκολη.

(48-54) Tο πρώτο synth επιλέγει (όπως και όλα τα ακόλουθα) τυχαία μία από τις αποθηκευμένες σε buffers κυματομορφές, και φτιάχνει μμία μελωδία που πατάει σε μία συγκεκριμένη μουσική σκάλα (ahirbhairav), ξεκινώντας από το midi number 60 και μετατρέποντας τις συγκεκριμένες σχέσεις με τη βάση 60 στην παραπάνω κλίμακα σε συχνότητες στις οποίες θα επαναλάβει την τυχαία επιλεγμένη κυματομορφή. Χρησιμοποιείται μία γεννήτρια περιβάλλουσας, η οποία επιλέγεται να ελευθερώνει το synth μετά την ολοκλήρωσή της λειτουργίας της.

(58-72) Ακολουθεί ένας ορισμός προτύπου-μοτίβου (pattern) χρήσης του παραπάνω synth και αυτής της σκάλας με κάποιες συναρτήσεις τυχαιότητας, άλλοτε εκθετικής (Pexprand) κι άλλοτε χωρίς κάποια τάση προτίμησης τιμών προς μία κατεύθυνση (π.χ. Pwhite).

(76-86) Ορίζεται το reverb, με μείωση της ενίσχυσης για αποφυγή ψαλιδισμού και με βάση τηn κατάλληλη δρομολόγηση των busses (είσοδοι-έξοδοι).

(88-92) Το πρώτο pattern μπαίνει σε λειτουργία με επιλογή τερματισμού. Η γραμμή του reverb (βλ. γραμμή 90) περιλαμβάνει τον όρο '\addToTail', ώστε να αποκλειστεί κάθε ενδεχόμενο λάθος ιεράρχησης και σειράς evaluation των γραμμών, σε περίπτωση τροποποίησης του κώδικα, καθώς το reverb χρειάζεται υπάρχον σήμα για να του προσθέσει την αντήχηση.

(96-97) Δεύτερο pattern που επιτρέπει την απεικόνιση των τιμών που πραγματώνει σε πραγματικό χρόνο στο post window, πράγμα που βοηθάει, καθώς ακολουθεί έναν ιδιόρρυθμο αλγόριθμο παραγωγής αλληλουχίας παλμών. Συχνοτικά, όλοι οι ήχοι προέρχονται από μία όχι τελείως αυθαίρετη, σχεδόν αρμονική σειρά, καθώς επιλέγονται βάσει στρογγυλοποίησης.

(99-101) Επιπλέον ενδεικτικά προαιρετικά synths

(107-118) Το πρώτο synth που χρησιμοποιεί μία τυχαία επιλεγμένη κυματομορφή ως ευρετήριο για τον Shaper που θα παράγει τελικά το κύριο σήμα. Ο (wave)shaper στην πραγματικότητα καθορίζει τη σειρά με την οποία συγκεκριμένα τμήματα της κυματομορφής διαβάζονται σε συγκεκριμένες χρονικές στιγμές και για συγκεκριμένες χρονικές διάρκειες (με συγκεκριμένο ρυθμό), στη δική μας περίπτωση βάσει της αποθηκευμένης κυματομορφής που ορίζουν με βάση τις δικές της τιμές (κατευθυντικότητα στο χρόνο και rate (frequency) ανάγνωσης) τις μόλις αναφερθείσες παραμέτρους. Μάλιστα ο τρόπος που λειτουργεί το ευρετήριο εδώ ελέγχεται από τη θέση του ποντικιού στον οριζόντιο άξονα, η οποία καθορίζει το τμήμα της κυματομορφής που κατατάσσεται στο ευρετήριο, αλλάζοντας τελικά δηλαδή την ένταση του σήματος. 

(124-140) Εδώ παρέχεται ένα πειραματικό, μινιμαλιστικό, ρυθμικό synth pattern (αν και χρησιμοποιεί τη routine και όχι το pattern για να δημιουργήσει τη μουσική φράση), που βασίζεται στην υπέρβαση των υπολογιστικών-αποθηκευτικών ορίων του συστήματος, και πιο συγκεκριμένα στο lag error. Μάλιστα, κάνει χρήση της μεθόδου ελέγχου 'while loop' για την επανάληψη της routine. Οι πολλαπλές iterations της αναπαραγωγής των αρχείων στα buffers δεν επιτρέπουν στο σύστημα να πραγματοποιήσει όλες αυτές που ανήκουν στην ίδια γραμμή (π.χ. το 50.do) την ίδια στιγμή, με αποτέλεσμα την αναπαραγωγή τους σε σειρά, σαν να επαναλαμβάνονται με μία σχεδόν σταθερή συχνότητα (η οποία υποθέτω θα είναι για το 50.do 50* τη χρονική διάρκεια του sample + όσα msecs είναι το lag).

(143-160) 



        
	

